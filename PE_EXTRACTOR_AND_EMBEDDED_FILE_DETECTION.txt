================================================================================
BINWALK PE EXTRACTOR IMPLEMENTATION AND EMBEDDED FILE DETECTION FIX
================================================================================
Date: November 14, 2025
Author: AI Assistant

================================================================================
PART 1: PE EXTRACTOR IMPLEMENTATION
================================================================================

ISSUE:
------
Binwalk had PE signature detection but no extractor to extract PE files from
firmware images or other binary files.

SOLUTION:
---------
Implemented a complete PE file extractor following the pattern of the 
android_sparse_extractor.

FILES CREATED:
--------------
1. src/extractors/pe.rs
   - pe_extractor() function returning Extractor definition
   - extract_pe_file() internal extractor function
   - Extracts PE files as "executable.exe"

FILES MODIFIED:
---------------
1. src/structures/pe.rs
   - Added PEFile struct (stores machine type and size)
   - Added parse_pe_file() function that:
     * Parses DOS header and PE header
     * Iterates through all section headers
     * Calculates total PE file size from section offsets
     * Returns machine type and total size

2. src/signatures/pe.rs
   - Updated pe_parser() to use parse_pe_file()
   - Now reports PE file size in description
   - Falls back to header-only parsing if full parse fails

3. src/extractors.rs
   - Added: pub mod pe;

4. src/magic.rs
   - Changed PE signature extractor from None to:
     extractor: Some(extractors::pe::pe_extractor())

TESTING:
--------
✓ Successfully tested with PE sample at:
  /home/jerryc/workspace/static-analyzer/plugins/media/src/file_analysis_plugins_media/impl/bin/4E
✓ Correctly identifies: "Windows PE binary, machine type: Intel x86-64, size: 7168 bytes"
✓ Successfully extracts PE file as executable.exe
✓ Extracted file is byte-for-byte identical (verified with md5sum)
✓ Works with PE files at offset 0 and embedded at other offsets


================================================================================
PART 2: EMBEDDED FILE DETECTION FIX (WAV with embedded PE)
================================================================================

ISSUE:
------
Binwalk failed to detect and extract a PE file embedded inside a WAV file at
offset 0x4E (78 bytes). The PE file was hidden inside the RIFF/WAV structure.

Sample file: /mnt/NAS/Work/SA_engine/media/sample/wav/malicious/
             dd8b498e5e72a5ce6c6b67db3342056dea03d19adb7be4aa377e3263fe8be44d

File structure:
- Offset 0x00: RIFF header (size: 7246 bytes)
- Offset 0x4E: PE executable (MZ header)

ROOT CAUSE:
-----------
Binwalk's design intentionally skips scanning inside already-identified file
structures to avoid false positives and improve performance. The scanning logic:

1. Found RIFF signature at offset 0 with size 7246 bytes
2. Set next_valid_offset = 7246 (end of RIFF)
3. Skipped scanning from offset 0 to 7246
4. PE at offset 78 was never checked
5. Even with -a flag, PE was filtered out as "conflicting data"

The -a (--search-all) flag was not properly implemented to override these
skip behaviors.

SOLUTION:
---------
Modified src/binwalk.rs to properly honor the -a flag for deep scanning of
embedded files:

FILES MODIFIED:
---------------
1. src/binwalk.rs

   Change 1: Added full_search tracking field
   -----------------------------------------
   Line ~67: Added to Binwalk struct:
   
   /// If true, scan all offsets including inside identified file structures
   pub full_search: bool,

   Line ~139: Set field in configure() function:
   
   let mut new_instance = Binwalk {
       full_search,
       ..Default::default()
   };

   Change 2: Modified signature skip logic
   ----------------------------------------
   Line ~398-407: Modified the code that skips to end of signatures:
   
   BEFORE:
   // Only update the next_valid_offset if confidence is at least medium
   if signature_result.confidence >= signatures::common::CONFIDENCE_MEDIUM {
       if signature_result.size > 0 {
           next_valid_offset = signature_end_offset;
           break;
       }
   }
   
   AFTER:
   // Only update the next_valid_offset if confidence is at least medium 
   // and full_search is not enabled
   if !self.full_search
       && signature_result.confidence >= signatures::common::CONFIDENCE_MEDIUM
   {
       if signature_result.size > 0 {
           next_valid_offset = signature_end_offset;
           break;
       }
   } else if self.full_search {
       debug!("Full search mode: continuing scan after signature at offset {:#X}", 
              magic_offset);
   }

   Change 3: Modified conflict filtering
   --------------------------------------
   Line ~490: Modified the code that filters overlapping signatures:
   
   BEFORE:
   } else if this_signature.offset < next_valid_offset {
       debug!("Signature {} at offset {:#X} contains conflicting data; ignoring",
              this_signature.name, this_signature.offset);
       file_map.remove(i);
       index_adjustment += 1;
       continue;
   }
   
   AFTER:
   // Unless full_search mode is enabled, in which case we want to find 
   // all signatures everywhere
   } else if !self.full_search && this_signature.offset < next_valid_offset {
       debug!("Signature {} at offset {:#X} contains conflicting data; ignoring",
              this_signature.name, this_signature.offset);
       file_map.remove(i);
       index_adjustment += 1;
       continue;
   }

USAGE:
------
To detect and extract embedded files inside other file structures:

# Detect embedded files
binwalk -a malicious.wav

# Detect and extract embedded files  
binwalk -ae malicious.wav

TESTING:
--------
✓ Successfully detects RIFF at offset 0x0
✓ Successfully detects PE at offset 0x4E (78) inside the RIFF structure
✓ Successfully extracts the embedded PE executable
✓ Extracted PE is valid: PE32+ executable (GUI) x86-64, for MS Windows
✓ Works with both test files and original malicious sample

OUTPUT WITH -a FLAG:
--------------------
DECIMAL     HEXADECIMAL     DESCRIPTION
0           0x0             RIFF image, encoding type: WAVE, total size: 7246 bytes
78          0x4E            Windows PE binary, machine type: Intel x86-64, size: 7168 bytes

[#] Extraction of riff data at offset 0x0 declined
[+] Extraction of pe data at offset 0x4E completed successfully

BEHAVIOR WITHOUT -a FLAG:
-------------------------
Without the -a flag, binwalk will only show the outer RIFF container and skip
the embedded PE (original behavior preserved for performance).

DECIMAL     HEXADECIMAL     DESCRIPTION
0           0x0             RIFF image, encoding type: WAVE, total size: 7246 bytes


================================================================================
TECHNICAL DETAILS
================================================================================

PE FILE SIZE CALCULATION:
-------------------------
The PE file size is calculated by:
1. Parsing DOS header to get PE header offset (e_lfanew)
2. Parsing PE header to get number of sections and optional header size
3. Iterating through each section header
4. Finding the maximum (section_offset + section_size)
5. Returning this maximum as the total PE file size

This ensures we extract the complete PE file including all sections.

AHO-CORASICK SCANNING:
----------------------
Binwalk uses Aho-Corasick algorithm with find_overlapping_iter() to find
magic byte patterns. The algorithm naturally finds overlapping patterns,
but the binwalk logic was filtering them out for performance. The -a flag
now preserves these overlapping matches.

FULL_SEARCH MODE:
-----------------
When full_search is true (via -a flag):
1. All signatures are scanned throughout the entire file
2. Short signatures are included in the full scan
3. Signatures inside other signatures are not filtered out
4. The scan continues byte-by-byte instead of jumping to end of structures

This enables detection of:
- Polyglot files
- Steganography
- Malicious embedded executables
- Hidden payloads in multimedia files
- Firmware with embedded archives


================================================================================
SECURITY IMPLICATIONS
================================================================================

This fix is particularly important for security analysis because:

1. MALWARE DETECTION: Malware often hides executables inside benign-looking
   files (images, audio, documents) to evade detection.

2. POLYGLOT FILES: Files that are valid in multiple formats can exploit
   parser differences for malicious purposes.

3. STEGANOGRAPHY: Embedded payloads hidden within multimedia files.

4. FIRMWARE SECURITY: Firmware may contain multiple layers of nested archives
   and executables that need thorough analysis.

The -a flag should be used when:
- Analyzing potentially malicious files
- Performing deep forensic analysis
- Auditing firmware for hidden components
- Detecting steganographic content


================================================================================
BACKWARD COMPATIBILITY
================================================================================

These changes maintain full backward compatibility:

1. Default behavior (without -a) unchanged - still skips embedded signatures
   for performance
2. PE signature detection works as before
3. PE extraction is now available (was missing before)
4. -a flag now works as documented - searches all offsets


================================================================================
SUMMARY
================================================================================

IMPLEMENTED:
1. ✓ Complete PE file extractor
2. ✓ PE file size calculation from section headers
3. ✓ Fixed -a flag to enable deep embedded file scanning
4. ✓ Maintained backward compatibility

TESTED:
1. ✓ PE extraction from standalone files
2. ✓ PE extraction from embedded locations
3. ✓ Malicious WAV with embedded PE
4. ✓ Full search mode with -a flag

RESULT:
Binwalk can now properly extract PE files and detect embedded executables
hidden inside multimedia and other container formats when using the -a flag.

================================================================================
